#  Задача 1

Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.

Вы как инженер поддержки решили произвести данную операцию:

- напишите список операций, которые вы будете производить для остановки запроса пользователя

Получаем идентификатор операции - opid:

```
db.currentOp({ "active" : true, "secs_running" : { "$gt" : 180 }})
```

Принудительно завершаем операцию:

```
db.killOp(opid)
```


- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

Использовать оператор $maxTimeMS - указывает совокупный лимит времени в миллисекундах для обработки операций.


#  Задача 2

Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

Проблема скорей всего в том что вся память занята истекшими в один и тот же момент ключами которые еще не удаленны. Так как Redis использует в основном однопоточную конструкцию, поэтому все запросы обслуживаются последовательно, в связи с этим пока не выполнится очистка, все операции записи блокируются.


#  Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:

```
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

1. Слишком объемные запросы, необходимо увеличение параметра net_read_timeout
2. Малое значение параметра connect_timeout, клиент не успевает установить соединение.
3. Размер сообщения/запроса превышает размер буфера max_allowed_packet на сервере или max_allowed_packet на строне клиента.

Какие пути решения данной проблемы вы можете предложить?

1. Увеличить на сервере MySQL wait_timeout, max_allowed_packet, net_write_timeout и net_read_timeout
2. В SQLAlchemy уменьшить pool_recycle, wait_timeout
3. При исчезновении ошибки Lost connection to MySQL server during query, возвращать по одному параметры в исходное состояние - для локализации проблемы.

#  Задача 4

Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

```
postmaster invoked oom-killer
```

Как вы думаете, что происходит?

Postgres недостаточно памяти.
Когда у сервера/процесса заканчивается память, Linux предлагает два пути решения: обрушить систему или завершить процесс, который съедает память.
Out-Of-Memory Killer —  процесс, который завершает приложение, чтобы спасти ядро от сбоя. Он жертвует приложением, чтобы сохранить работу ОС.

Как бы вы решили данную проблему?

1. Добавить ресурсов (RAM), отключить ненужные приложения.
2. Можно поиграть с параметрами, которые регулируют память в Postgres из основных это: 

max_connections, shared_buffer, work_mem, effective_cache_size, maintenance_work_mem.

shared_buffer - этот параметр устанавливает, сколько выделенной памяти будет использоваться PostgreSQL для кеширования.

wal_buffers - PostgreSQL сначала записывает записи в WAL (журнал пред записи) в буферы, а затем эти буферы сбрасываются на диск. Размер буфера по умолчанию, определенный wal_buffers, составляет 16 МБ. Но если у нас много одновременных подключений, то более высокое значение может повысить производительность.

effective_cache_size - предоставляет оценку памяти, доступной для кэширования диска. Это всего лишь ориентир, а не точный объем выделенной памяти или кеша. Он не выделяет фактическую память, но сообщает оптимизатору объем кеша, доступный в ядре. Если значение этого параметра установлено слишком низким, планировщик запросов может принять решение не использовать некоторые индексы, даже если они будут полезны. Поэтому установка большого значения всегда имеет смысл.

work_mem - если нам нужно выполнить сложную сортировку, увеличьте значение work_mem для получения хороших результатов. Сортировка в памяти происходит намного быстрее, чем сортировка данных на диске. Установка очень высокого значения может стать причиной узкого места в памяти для нашей среды, поскольку этот параметр относится к операции сортировки пользователя.

maintenance_work_mem - это параметр памяти, используемый для задач обслуживания.